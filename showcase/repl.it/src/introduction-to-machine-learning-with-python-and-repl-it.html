<!DOCTYPE html>
<html lang="en">
<head>
<link rel='canonical' href='https://www.codementor.io/@garethdwyer/introduction-to-machine-learning-with-python-and-repl-it-rln7ywkhc'>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Introduction to Machine Learning with Python and repl.it</title>
<style>
@import url(//cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.0/css/font-awesome.css);
/* normalize.css v2.1.1 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address styling not present in IE 8/9. */
[hidden] { display: none; }

/* ========================================================================== Base ========================================================================== */
/** 1. Prevent system color scheme's background color being used in Firefox, IE, and Opera. 2. Prevent system color scheme's text color being used in Firefox, IE, and Opera. 3. Set default font family to sans-serif. 4. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { background: #fff; /* 1 */ color: #000; /* 2 */ font-family: sans-serif; /* 3 */ -ms-text-size-adjust: 100%; /* 4 */ -webkit-text-size-adjust: 100%; /* 4 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

a:focus { outline: none; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #111111; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #ad141e; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #ad141e; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.5; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Helvetica Neue", "Helvetica", Arial, sans-serif; font-weight: normal; font-style: normal; color: #111111; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #5e5e5e; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Andale Mono", "monotype.com", "Lucida Console", monospace; font-weight: normal; color: #222222; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.5; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }

blockquote, blockquote p { line-height: 1.5; color: #6f6f6f; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Print styles.  Inlined to avoid required HTTP connection: www.phpied.com/delay-loading-your-print-css/ Credit to Paul Irish and HTML5 Boilerplate (html5boilerplate.com)
*/
.print-only { display: none !important; }

@media print { * { background: transparent !important; color: #000 !important; /* Black prints faster: h5bp.com/s */ box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; /* h5bp.com/t */ }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.2; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; padding: 2px; white-space: nowrap; background-color: #eeeeee; border: 0 solid #dddddd; -webkit-border-radius: 0; border-radius: 0; text-shadow: none; }

pre, pre > code { line-height: 1.5; color: white; font-family: Monaco, Consolas, "Courier New", Courier, Sans-serif; font-weight: normal; }

kbd.keyseq { color: #555555; }

kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }

kbd kbd:first-child { margin-left: 0; }

kbd kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: #090909; }

p a > code:hover { color: #151515; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }

#toc { border-bottom: 1px solid #dddddd; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }

#toctitle { color: #111111; }

@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #dddddd; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #dddddd; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 0; border-radius: 0; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }

#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", sans-serif; font-size: 1em; padding-left: 0.125em; }

#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }

#footer-text { color: #dddddd; line-height: 1.35; }

.sect1 { padding-bottom: 1.25em; }

.sect1 + .sect1 { border-top: 1px solid #dddddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #111111; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #040404; }

.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }

.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 0; border-radius: 0; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }

.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 0; border-radius: 0; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #111111; margin-top: 0; line-height: 1.5; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock > .content pre, .listingblock > .content pre { background: #333333; border-width: 0; padding: 10px; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }

.listingblock > .content { position: relative; }

.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }

.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }

table.pyhltable { border: 0; margin-bottom: 0; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }

.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }

.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }

table thead th, table tfoot th { font-weight: bold; }

table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 0; border-radius: 0; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }

table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }

table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }

table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }

th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }

th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }

th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }

th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }

th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }

th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }

p.tableblock.header { color: #222222; font-weight: bold; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1 { padding-right: .8em; font-weight: bold; }

td.hdlist1, td.hdlist2 { vertical-align: top; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.qanda > ol > li > p > em:only-child { color: #96111a; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; }

span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }

.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #ad141e; color: #820f16; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }

</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction_to_machine_learning_with_python_and_repl_it">Introduction to Machine Learning with Python and repl.it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this tutorial, we’re going to walk through how to set up a basic
Python <a href="https://repl.it">repl</a> that can learn the difference between two
categories of sentences, positive and negative. For example, if you had
the sentence &#8220;I love it!&#8221;, we want to train a machine to know that
this sentence is associated with happy and positive emotions. If we have
a sentence like &#8220;it was really terrible&#8221;, we want the machine to label
it as a negative or sad sentence.</p>
</div>
<div class="paragraph">
<p>The maths, specifically calculus and linear algebra, behind machine
learning gets a bit hairy. We’ll be abstracting this away with the
Python library <a href="https://scikit-learn.org/">scikit-learn</a>, which makes it
possible to do advanced machine learning in a few lines of Python.</p>
</div>
<div class="paragraph">
<p>At the end of this tutorial you’ll understand the fundamental ideas of
automatic classification and have a program that can learn by itself to
distinguish between different categories of text. You’ll be able to use
the same code to learn new categories (e.g. spam/not-spam, or
clickbait/non-clickbait).</p>
</div>
<div class="sect2">
<h3 id="_prerequisites">Prerequisites</h3>
<div class="paragraph">
<p>To follow along this tutorial, you should have at least basic knowledge
of Python or a similar programming language. Ideally, you should also
sign up for a <a href="https://repl.it">repl.it</a> account so that you can modify
and extend the bot we build, but it’s not completely necessary.</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_up">Setting up</h3>
<div class="paragraph">
<p>If you’re following along using repl.it, then visit the homepage and
login or create a new account. Follow the prompts to create your first
Repl, and choose &#8220;Python&#8221;. You’ll be taken to a new Repl project where
you can run Python code and immediately see the output, which is great
for rapid development.</p>
</div>
<div class="paragraph">
<p>The first thing we need to do is install scikit-learn, which is a really
nice Python library to get started with machine learning. Create a new
file using the &#8220;add file&#8221; button at the top left, call the file
<code>requirements.txt</code> (the exact name is important – it’s a special file
that repl will look for dependencies in and install them automatically),
and add the line <code>scikit-learn</code> to the top of the new file that gets
created.</p>
</div>
<div class="paragraph">
<p>You should see the library installing through the output produced in the
right-hand panel, as in the image below.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://cdn.filestackcontent.com/ABu0DokgQmKBxPp5Mlvk" alt="repl-start-screen.png"></span></p>
</div>
<div class="paragraph">
<p>Now you have the powerful and simple scikit-learn available! Let’s learn
how to use it. Open the <code>main.py</code> file that Repl created for you
automatically and add the following two imports to the top.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from sklearn import tree
from sklearn.feature_extraction.text import CountVectorizer</code></pre>
</div>
</div>
<div class="paragraph">
<p>In line 1, we import the <code>tree</code> module, which will give us a Decision
Tree classifier that can learn from data. In line 2, we import a
vectoriser – something that can turn text into numbers. We’ll describe
each of these in more detail soon!</p>
</div>
<div class="paragraph">
<p>Throughout the next steps, you can hit the big green &#8220;run&#8221; button to
run your code, check for bugs, and view output along the way (you should
do this every time you add new code).</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_some_mock_data">Creating some mock data</h3>
<div class="paragraph">
<p>Before we get started with the exciting part, we’ll create a very simple
dataset – too simple in fact. You might not see the full power of
machine learning at first as our task will look so easy, but once we’ve
walked through the concepts, it’ll be a simple matter of swapping the
data out for something bigger and more complicated.</p>
</div>
<div class="paragraph">
<p>On the next lines of main.py add the following lines of code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">positive_texts = [
    "we love you",
    "they love us",
    "you are good",
    "he is good",
    "they love mary"
]

negative_texts =  [
    "we hate you",
    "they hate us",
    "you are bad",
    "he is bad",
    "we hate mary"
]

test_texts = [
    "they love mary",
    "they are good",
    "why do you hate mary",
    "they are almost always good",
    "we are very bad"
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We’ve created three simple datasets of five sentences each. The first
one contains positive sentences; the second one contains negative
sentences; and the last contains a mix of positive and negative
sentences.</p>
</div>
<div class="paragraph">
<p>It’s immediately obvious to a human which sentences are positive and
which are negative, but can we teach a computer to tell them apart?</p>
</div>
<div class="paragraph">
<p>We’ll use the two lists <code>positive_texts</code> and <code>negative_texts</code> to
<em>train</em> our model. That is, we’ll show these examples to the computer
along with the correct answers for the question &#8220;is this text positive
or negative?&#8221;. The computer will try to find rules to tell the
difference, and then we’ll test how well it did by giving it
<code>test_texts</code> without the answers and ask it to guess whether each
example is positive or negative.</p>
</div>
</div>
<div class="sect2">
<h3 id="_understanding_vectorization">Understanding vectorization</h3>
<div class="paragraph">
<p>The first step in nearly all machine learning problems is to translate
your data from a format that makes sense to a human to one that makes
sense to a computer. In the case of language and text data, a simple but
effective way to do this is to associate each unique word in the dataset
with a number, from 0 onwards. Each text can then be represented by an
array of numbers, representing how often each possible word appears in
the text.</p>
</div>
<div class="paragraph">
<p>Let’s go through an example to see how this works. If we had the two
sentences</p>
</div>
<div class="paragraph">
<p><code>["nice pizza is nice"], ["what is pizza"]</code></p>
</div>
<div class="paragraph">
<p>then we would have a dataset with four unique words in it. The first
then we’d want to do is create a vocabulary mapping to map each unique
word to a unique number. We could do this as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">{
    "nice": 0,
    "pizza": 1,
    "is": 2,
    "what": 3
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create this, we simply go through both sentences from left to right,
mapping each new word to the next available number and skipping words
that we’ve seen before. Now we can again convert our sentences into bag
of words vectors as follows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">[
    [2, 1, 1, 0], # two "nice", one "pizza", one "is", zero "what"
    [0, 1, 1, 1]  # zero "nice", one "pizza", one "is", one "what"
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each sentence vector is always the same length as the <em>total</em> vocabulary
size. We have four words in total (across all of our sentences), so each
sentence is represented by an array of length four. Each position in the
array represents a word, and each value represents how often that word
appears in that sentence.</p>
</div>
<div class="paragraph">
<p>The first sentence contains the word &#8220;nice&#8221; twice, while the second
sentence does not contain the word &#8220;nice&#8221; at all. According to our
mapping, the zeroth element of each array should indicate how often the
word nice appears, so the first sentence contains a <code>2</code> in the
beginning and the second sentence contains a <code>0</code> there.</p>
</div>
<div class="paragraph">
<p>This representation is called &#8220;bag of words&#8221; because we lose all of
the information represented by the <em>order</em> of words. We don’t know, for
example, that the first sentence starts and ends with &#8220;nice&#8221;, only
that it contains the word &#8220;nice&#8221; twice.</p>
</div>
<div class="paragraph">
<p>With real data, these arrays get <em>very</em> long. There are millions of
words in most languages, so for a big dataset containing most words,
each sentence needs to be represented by a very long array, where nearly
all values are set to zero (all the words not in that sentence). This
could take up a lot of space, but luckily scikit-learn uses a clever
sparse-matrix implementation that doesn’t quite look like the above, but
the overall concept remains the same.</p>
</div>
<div class="paragraph">
<p>Let’s see how to achieve the above using scikit-learn’s optimised
vectoriser.</p>
</div>
<div class="paragraph">
<p>First we want to combine all of our &#8220;training&#8221; data (the data that
we’ll show the computer along with the correct labels of &#8220;positive&#8221; or
&#8220;negative&#8221; so that it can learn), so we’ll combine our positive and
negative texts into one array. Add the following code below the datasets
you created.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">training_texts = negative_texts + positive_texts
training_labels = ["negative"] * len(negative_texts) + ["positive"] * len(positive_texts)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our dataset now looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>['we hate you', 'they hate us', 'you are bad', 'he is bad', 'we hate mary', 'we love you', 'they love us', 'you are good', 'he is good', 'they love mary']
['negative', 'negative', 'negative', 'negative', 'negative', 'positive', 'positive', 'positive', 'positive', 'positive']</pre>
</div>
</div>
<div class="paragraph">
<p>The two arrays (texts and labels) are associated by index. The first
text in the first array is negative, and corresponds to the first label
in the second array, and so on.</p>
</div>
<div class="paragraph">
<p>Now we need a vectoriser to transform the texts into numbers. We can
create one in scikit-learn with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">vectorizer = CountVectorizer()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before we can use our vectorizer, it needs to run once through all the
data we have so it can build the mapping from words to indices. This is
referred to as &#8220;fitting&#8221; the vectoriser, and we can do it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">vectorizer.fit(training_texts)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want, we can see the mapping it created (which might not be in
order, as in the examples we walked through earlier, but each word will
have its own index). We can inspect the vectoriser’s vocabulary by
adding the line</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">print(vectorizer.vocabulary_)</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Note the underscore at the end. Scikit-learn uses this as a convention
for &#8220;helper&#8221; attributes. The mapping is explicit only for debugging
purposes and you shouldn’t need to use it in most cases). My vocabulary
mapping looked as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{'we': 10, 'hate': 3, 'you': 11, 'they': 8, 'us': 9, 'are': 0, 'bad': 1, 'he': 4, 'is': 5, 'mary': 7, 'love':6, 'good': 2}</pre>
</div>
</div>
<div class="paragraph">
<p>Behind the scenes, the vectoriser inspected all of our texts, did same
basic preprocessing like making everything lowercase, split the text
into words using a built-in <em>tokenization</em> method, and produced a
vocabulary mapping specific to our dataset.</p>
</div>
<div class="paragraph">
<p>Now that we have a vectorizer that knows what words are in our dataset,
we can use it to transform our texts into vectors. Add the following
lines of code to your Repl:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">training_vectors = vectorizer.transform(training_texts)
testing_vectors = vectorizer.transform(test_texts)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line creates a list of vectors which represent all of the
training texts, still in the same order, but now each text is a vector
of numbers instead of a string.</p>
</div>
<div class="paragraph">
<p>The second line does the same with the test vectors. The machine
learning part isn’t looking at our test texts (that would be cheating) –
it’s just mapping the words to numbers so that it can work with them
more easily. Note that when we called <code>fit()</code> on the vectoriser, we
only showed it the training texts. Because there are words in the test
texts that don’t appear in the training texts, these words will simply
be ignored and will not be represented in <code>testing_vectors</code>.</p>
</div>
<div class="paragraph">
<p>Now that we have a vectorised representation our problem, let’s take a
look at how we can solve it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_understanding_classification">Understanding classification</h3>
<div class="paragraph">
<p>A classifier is a statistical model that tries to predict a label for a
given input. In our case, the input is the text and the output is either
&#8220;positive&#8221; or &#8220;negative&#8221;, depending on whether the classifier thinks
that the input is positive or negative.</p>
</div>
<div class="paragraph">
<p>A machine learning classifier can be &#8220;trained&#8221;. We give it labelled
data and it tries to learn rules based on that data. Every time it gets
more data, it updates its rules slightly to account for the new
information. There are many kinds of classifiers, but one of the
simplest is called Decision Tree.</p>
</div>
<div class="paragraph">
<p>Decision trees learn a set of yes/no rules by building decisions into a
tree structure. Each new input moves down the tree, while various
questions are asked one by one. When the input filters all the way to a
leaf node in the tree, it acquires a label.</p>
</div>
<div class="paragraph">
<p>If that’s confusing, don’t worry! We’ll walk through a detailed example
with a picture soon to clarify. First, let’s show how to get some
results using Python.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">classifier = tree.DecisionTreeClassifier()
classifier.fit(training_vectors, training_labels)
predictions = classifier.predict(testing_vectors)
print(predictions)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly to the vectoriser, we first create a classifier by using the
module we imported at the start. Then we call <code>fit()</code> on the
classifier and pass in our training vectors and their associated labels.
The decision tree is going to look at both and attempt to learn rules
that separate the two kinds of data.</p>
</div>
<div class="paragraph">
<p>Once our classifier is trained, we can call the <code>predict()</code> method and
pass in previously unseen data. Here we pass in <code>testing_vectors</code>
which is the list of vectorized test data that the computer didn’t look
at during training. It has to try and apply the rules it learned from
the training data to this new &#8220;unseen&#8221; data. Machine learning is
pretty cool, but it’s not magic, so there’s no guarantee that the rules
we learned will be any good yet.</p>
</div>
<div class="paragraph">
<p>The code above produces the following output:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>['positive' 'positive' 'negative' 'positive' 'negative']</pre>
</div>
</div>
<div class="paragraph">
<p>Let’s take a look at our test texts again to see if these predictions
match up to reality.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"they love mary"
"they are good"
"why do you hate mary"
"they are almost always good"
"we are very bad"</pre>
</div>
</div>
<div class="paragraph">
<p>The output maps to the input by index, so the first output label
(&#8220;positive&#8221;) matches up to the first input text (&#8220;they love mary&#8221;),
and the last output label (&#8220;negative&#8221;) matches up to the last input
text (&#8220;we are very bad&#8221;).</p>
</div>
<div class="paragraph">
<p>It looks like the computer got every example right! It’s not a difficult
problem to solve. The words &#8220;bad&#8221; and &#8220;hate&#8221; appear only in the
negative texts and the words &#8220;good&#8221; and &#8220;love&#8221;, only in the positive
ones. Other words like &#8220;they&#8221;, &#8220;mary&#8221;, &#8220;you&#8221; and &#8220;we&#8221; appear in
both good and bad texts. If our model did well, it will have learned to
ignore the words that appear in both kinds of texts, and focus on
&#8220;good&#8221;, &#8220;bad&#8221;, &#8220;love&#8221; and &#8220;hate&#8221;.</p>
</div>
<div class="paragraph">
<p>Decision Trees are not the most powerful machine learning model, but
they have one advantage over most other algorithms: after we have
trained them, we can look inside and see exactly how they work. More
advanced models like deep neural networks are nearly impossible to make
sense of after training.</p>
</div>
<div class="paragraph">
<p>Scikit-learn contains a useful &#8220;graphviz&#8221; helper to inspect tree-based
models. Add the following code to the end of your repl.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">tree.export_graphviz(
    classifier,
    out_file='tree.dot',
    feature_names=vectorizer.get_feature_names(),
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will create an export of the trained model which we can visualise.
Look for the new <code>tree.dot</code> file in the left-most pane that should
have been created after running the above code.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://cdn.filestackcontent.com/xWlG01RhTeWzHIObvXnl" alt="repl-file-viewer.png"></span></p>
</div>
<div class="paragraph">
<p>Copy the contents of this file (shown in the middle pane above) to your
clipboard and navigate to <a href="http://www.webgraphviz.com/" class="bare">http://www.webgraphviz.com/</a>. Paste the Tree
representation into the big input box on the page you see and press
&#8220;Generate Graph&#8221;</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://cdn.filestackcontent.com/SN6CImYtTSOflOntRSeO" alt="graph-viz-online.png"></span></p>
</div>
<div class="paragraph">
<p>You should see a tree graph that looks as follows.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://cdn.filestackcontent.com/m9c1SDznSoqGOvDxMdVM" alt="decision-tree-vis.png"></span></p>
</div>
<div class="paragraph">
<p>The above shows a decision tree that only learned two rules. The first
rule (top square) is about the word &#8220;hate&#8221;. The rule is &#8220;is the
number of times &#8216;hate&#8217; occurs in this sentence less than or equal to
0.5&#8221;. None of our sentences contain duplicate words, so each rule will
really be only about whether the word appears or not (you can think of
the <code>&lt;= 0.5</code> rules as <code>&lt; 1</code> in this case).</p>
</div>
<div class="paragraph">
<p>For each question in our training dataset, we can ask if the first rule
is True or False. If the rule is True for a given sentence, we’ll move
that sentence down the tree left (following the &#8220;True&#8221; arrow). If not,
we’ll go right (following the &#8220;False&#8221; arrow).</p>
</div>
<div class="paragraph">
<p>Once we’ve asked this first question for each sentence in our dataset,
we’ll have three sentences for which the answer is &#8220;False&#8221;, because
three of our training sentences contain the word &#8220;hate&#8221;. These three
sentences go right in the decision tree and end up at first leaf node
(an end node with no arrows coming out the bottom). This leaf node has
<code>value = [3, 0]</code> in it, which means that three samples reach this
node, and three belong to the negative class and zero to the positive
class.</p>
</div>
<div class="paragraph">
<p>For each sentence where the first rule is &#8220;True&#8221; (the word &#8220;hate&#8221;
appears less than 0.5 times, or in our case 0 times), we go down the
left of the tree, to the node where <code>value = [2,5]</code>. This isn’t a leaf
node (it has more arrows coming out the bottom), so we’re not done yet.
At this point we have two negative sentences and all five positive
sentences still.</p>
</div>
<div class="paragraph">
<p>The next rule is &#8220;bad &#8656; 0.5&#8221;. In the same way as before, we’ll go
down the right path if we have more than 0.5 occurrences of &#8220;bad&#8221; and
left if we have fewer than 0.5 occurrences of &#8220;bad&#8221;. For the last two
negative sentences that we are still evaluating (the two containing
&#8220;bad&#8221;), we’ll go <em>right</em> and end up at the node with <code>value=[2,0]</code>.
This is another leaf node and when we get here we have two negative
sentences and zero positive ones.</p>
</div>
<div class="paragraph">
<p>All other data will go left, and we’ll end up at <code>[0,5]</code>, or zero
negative sentences and five positive ones.</p>
</div>
<div class="paragraph">
<p>As an exercise, take each of the test sentences (not represented in the
annotated tree above) and try to follow the set of rules for each one.
If it ends up in a bucket with more negative sentences than positive
ones (either of the right branches), it’ll be predicted as a negative
sentence. If it ends up in the left-most leaf node, it’ll be predicted
as a positive sentence.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_a_manual_classifier">Building a manual classifier</h3>
<div class="paragraph">
<p>When the task at hand is this simple, it’s often easier to write a
couple of rules manually rather than using Machine Learning. For this
dataset, we could have achieved the same result by writing the following
code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def manual_classify(text):
    if "hate" in text:
        return "negative"
    if "bad" in text:
        return "negative"
    return "positive"

predictions = []
for text in test_texts:
    prediction = manual_classify(text)
    predictions.append(prediction)
print(predictions)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have replicated the decision tree above. For each sentence, we
check if it contains &#8220;hate&#8221; and if it does we classify it as negative.
If it doesn’t, we check if it contains &#8220;bad&#8221;, and if it does, we
classify it as negative. All other sentences are classified as positive.</p>
</div>
<div class="paragraph">
<p>So what’s the difference between machine learning and traditional
rule-based models like this one? The main advantage of learning the
rules directly is that it doesn’t really get more difficult as the
dataset grows. Our dataset was trivially simple, but a real-world
dataset might need thousands or millions of rules, and while we could
write a more complicated set of if-statements &#8220;by hand&#8221;, it’s much
easier if we can teach machines to learn these by themselves.</p>
</div>
<div class="paragraph">
<p>Also, once we’ve perfected a set of manual rules, they’ll still only
work for a single dataset. But once we’ve perfected a machine learning
model, we can use it for many tasks, simply by changing the input data!</p>
</div>
<div class="paragraph">
<p>In the example we walked through, our model was a perfect student and
learned to correctly classify all five unseen sentences, this is not
usually the case for real-world settings. Because machine learning
models are based on probability, the goal is to make them as accurate as
possible, but in general you will not get 100% accuracy. Depending on
the problem, you might be able to get higher accuracy by hand-crafting
rules yourself, so machine learning definitely isn’t the correct tool to
solve all classification problems.</p>
</div>
<div class="paragraph">
<p>Try the code on bigger datasets to see how it performs. There is no
shortage of interesting data sets to experiment with. I wrote another
machine learning walkthrough
<a href="https://www.codementor.io/garethdwyer/introduction-to-machine-learning-with-python-s-scikit-learn-czha398p1">here</a>
that shows how to use a larger clickbait dataset to teach a machine how
to classify between clickbait articles and real ones, using similar
methods to those described above. That tutorial uses an SVM classifier
and a more advanced vectorisation method, but see if you can load the
dataset from there into the classifier we built in this tutorial and
compare the results.</p>
</div>
<div class="paragraph">
<p>You can fork this repl here:
[<a href="https://repl.it/@GarethDwyer1/machine-learning-intro" class="bare">https://repl.it/@GarethDwyer1/machine-learning-intro</a>](<a href="https://repl.it/@GarethDwyer1/machine-learning-intro" class="bare">https://repl.it/@GarethDwyer1/machine-learning-intro</a>)
to keep hacking on it (it’s the same code as we walked through above but
with some comments added.) If you prefer, the entire program is shown
below so you can copy paste it and work from there.</p>
</div>
<div class="paragraph">
<p>If you want to try your hand at machine learning, join the
<a href="https://repl.it/talk/challenge/AI/10058">repl.it AI competition</a> that is
running until 11 February. You can get general help by joining the Repl
<a href="https://discord.gg/QWFfGhy">discord channel</a>, or if you have questions
specifically about this tutorial feel free to leave a comment below or
to <a href="https://twitter.com/sixhobbits">tweet at me</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from sklearn import tree
from sklearn.feature_extraction.text import CountVectorizer

positive_texts = [
    "we love you",
    "they love us",
    "you are good",
    "he is good",
    "they love mary"
]

negative_texts =  [
    "we hate you",
    "they hate us",
    "you are bad",
    "he is bad",
    "we hate mary"
]

test_texts = [
    "they love mary",
    "they are good",
    "why do you hate mary",
    "they are almost always good",
    "we are very bad"
]

training_texts = negative_texts + positive_texts
training_labels = ["negative"] * len(negative_texts) + ["positive"] * len(positive_texts)

vectorizer = CountVectorizer()
vectorizer.fit(training_texts)
print(vectorizer.vocabulary_)

training_vectors = vectorizer.transform(training_texts)
testing_vectors = vectorizer.transform(test_texts)

classifier = tree.DecisionTreeClassifier()
classifier.fit(training_vectors, training_labels)

print(classifier.predict(testing_vectors))

tree.export_graphviz(
    classifier,
    out_file='tree.dot',
    feature_names=vectorizer.get_feature_names(),
)

def manual_classify(text):
    if "hate" in text:
        return "negative"
    if "bad" in text:
        return "negative"
    return "positive"

predictions = []
for text in test_texts:
    prediction = manual_classify(text)
    predictions.append(prediction)
print(predictions)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>